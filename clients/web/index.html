<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>á»¨NG Dá»¤NG Há»ŒC TÄ‚NG CÆ¯á»œNG TRONG VIá»†C Tá»I Æ¯U HÃ“A ÄÆ¯á»œNG ÄI Cá»¦A ROBOT</title>
<link rel="stylesheet" href="style.css">

<!-- CSS nhá» Ä‘á»ƒ sáº¯p xáº¿p 2 hÃ ng theo yÃªu cáº§u (khÃ´ng sá»­a logic JS) -->
<style>
  /* Layout: 2 hÃ ng - má»—i hÃ ng 2 card ngang */
  .main-container {
    display: flex;
    flex-direction: column;
    gap: 20px;
    padding: 18px;
  }
  .row {
    display: flex;
    gap: 20px;
    align-items: flex-start;
  }
  .row .card {
    flex: 1;
    min-width: 0;
  }
  /* Giá»¯ tÆ°Æ¡ng thÃ­ch khi style.css cÃ³ quy táº¯c khÃ¡c */
</style>
</head>
<body>
<div class="main-container">

  <!-- HÃ€NG 1: MÃ´i trÆ°á»ng (trÃ¡i) + Äiá»u khiá»ƒn (pháº£i) -->
  <div class="row">
    <div class="card simulation-card">
      <div class="card-header">
        <span class="card-icon">ğŸ¤–</span>
        <span class="card-title">MÃ´i TrÆ°á»ng MÃ´ Phá»ng</span>
        <span style="margin-left: auto; background: rgba(255,255,255,0.2); padding: 5px 10px; border-radius: 10px; font-size: 12px;">Sáºµn sÃ ng</span>
      </div>
      
      <div class="grid-container">
        <div class="grid" id="grid"></div>
        
        <div class="legend">
          <div class="legend-item">
            <div class="legend-color robot">ğŸ¤–</div>
            <span>Robot</span>
          </div>
          <div class="legend-item">
            <div class="legend-color goal"></div>
            <span>Má»¥c tiÃªu</span>
          </div>
          <div class="legend-item">
            <div class="legend-color obstacle"></div>
            <span>Váº­t cáº£n</span>
          </div>
          <div class="legend-item">
            <div class="legend-color waypoint"></div>
            <span>Äiá»ƒm trung gian</span>
          </div>
        </div>
        
        <div id="msg" class="status-message">MÃ´i trÆ°á»ng Ä‘Ã£ Ä‘Æ°á»£c reset</div>
      </div>
    </div>

    <div class="card combined-control-card">
      <div class="combined-content">
        <div class="control-section">
          <div class="section-header">
            <span class="card-icon">ğŸ®</span>
            <span class="card-title">Äiá»u Khiá»ƒn Robot</span>
          </div>
          
          <div class="button-group">
            <button class="btn btn-start" onclick="startAutoMove('random')">â–¶ Auto Move (Random)</button>
            <button class="btn btn-start" onclick="startAutoMove('greedy')">â–¶ Auto Move (Greedy)</button>
            <button class="btn btn-stop" onclick="stopAll()">ğŸ›‘ Stop</button>
          </div>
                    
          <div class="button-group">
            <button class="btn btn-reset" onclick="resetGrid()">ğŸ”„ Reset</button>
            <button class="btn btn-reset" onclick="resetAllGrid()">ğŸŒ Reset All</button>
            <button class="btn btn-debug" onclick="toggleDebug()">ğŸ”§ Debug</button>
          </div>
          
          <div id="manualControls" class="manual-controls" style="display:none;">
            <h4 style="text-align:center; margin-bottom:10px;">Äiá»u khiá»ƒn thá»§ cÃ´ng</h4>
            <div class="direction-buttons">
              <button class="btn btn-debug" onclick="manualMove('up')">â†‘</button>
              <button class="btn btn-debug" onclick="manualMove('right')">â†’</button>
              <button class="btn btn-debug" onclick="manualMove('down')">â†“</button>
              <button class="btn btn-debug" onclick="manualMove('left')">â†</button>
            </div>
          </div>
        </div>

        <div class="algorithm-section">
          <div class="section-header">
            <span class="card-icon">ğŸ§ </span>
            <span class="card-title">Thuáº­t ToÃ¡n Há»c TÄƒng CÆ°á»ng</span>
          </div>
          
          <div class="algorithm-buttons">
            <button class="btn-algorithm" onclick="runAlgorithm('MC')">Monte Carlo</button>
            <button class="btn-algorithm" onclick="runAlgorithm('Q-learning')">Q-Learning</button>
            <button class="btn-algorithm" onclick="trainAndRunSarsa()">SARSA</button>
            <button class="btn-algorithm" onclick="runAlgorithm('A2C')">A2C</button>
            <button class="btn-algorithm" onclick="runAStar()">A*</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- HÃ€NG 2: Reward (trÃ¡i) + Thá»‘ng kÃª hiá»‡u suáº¥t (pháº£i) -->
  <div class="row">
    <div class="card stats-card">
      <div class="card-header">
        <span class="card-icon">ğŸ“ˆ</span>
        <span class="card-title">Biá»ƒu Ä‘á»“ miá»n thá»ƒ hiá»‡n hÃ m pháº§n thÆ°á»Ÿng theo bÆ°á»›c Ä‘i</span>
      </div>
      <canvas id="rewardChart" width="300" height="240"></canvas>
    </div>

    <div class="card stats-card">
      <div class="card-header">
        <span class="card-icon">ğŸ“Š</span>
        <span class="card-title">Thá»‘ng KÃª Hiá»‡u Suáº¥t</span>
      </div>
      
      <div class="stats-grid">
        <div class="stat-item">
          <div class="stat-label">THUáº¬T TOÃN</div>
          <div class="stat-value" id="current-algorithm">-</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">REWARD</div>
          <div class="stat-value" id="current-reward">-</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">STEP</div>
          <div class="stat-value" id="current-steps">-</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">WAYPOINTS</div>
          <div class="stat-value" id="current-waypoints">-</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">THá»œI GIAN</div>
          <div class="stat-value" id="current-time">-</div>
        </div>
      </div>
      
      <div id="algoResult" class="algo-result" style="display:none;"></div>

      <canvas id="trajectory" width="300" height="240" style="border:1px solid #ccc; margin-top:10px;"></canvas>
    </div>
  </div>

</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
// ---------------- Biáº¿n toÃ n cá»¥c ----------------
let gridSizeX = 10, gridSizeY = 8;
let robotPos = [0, 0], goal = [9, 7], obstacles = [], waypoints = [], visitedWaypoints = [];
let autoMoving = false, algoMoving = false, intervalId = null, debugMode = false, currentAlgo = null;
let startTime = null, endTime = null, trajectoryPoints = [];
let allAlgoData = {};

// ---------------- Chart ----------------
const ctx = document.getElementById('rewardChart').getContext('2d');
const rewardChart = new Chart(ctx, {
    type: 'line', data: { labels: [], datasets: [] },
    options: { responsive:true, plugins:{ title:{ display:true, text:'Reward theo Step' } }, scales:{ x:{ title:{ display:true, text:'Step' } }, y:{ title:{ display:true, text:'Reward' } } } }
});

function randomColor(alpha=1){ return `rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${alpha})`; }

function updateChart() {
    rewardChart.data.datasets = [];
    let maxSteps = 0;
    for (const algo in allAlgoData) { if (allAlgoData[algo].rewards.length > maxSteps) maxSteps = allAlgoData[algo].rewards.length; }
    rewardChart.data.labels = Array.from({length: maxSteps}, (_, i) => i + 1);
    for (const algo in allAlgoData) {
        rewardChart.data.datasets.push({
            label: algo, data: allAlgoData[algo].rewards, borderColor: allAlgoData[algo].color,
            backgroundColor: allAlgoData[algo].color.replace('rgb', 'rgba').replace(')', ', 0.2)'),
            fill: false, tension: 0.3, pointRadius: 0
        });
    }
    rewardChart.update();
}

// ---------------- Grid & Robot ----------------
function drawGridOnce(){
    let grid=document.getElementById("grid");
    grid.style.gridTemplateColumns=`repeat(${gridSizeX},35px)`;
    grid.innerHTML="";
    for(let y=0;y<gridSizeY;y++){
        for(let x=0;x<gridSizeX;x++){
            let cell=document.createElement("div");
            cell.classList.add("cell");
            cell.dataset.x=x; cell.dataset.y=y;
            if(obstacles.some(o=>o[0]===x&&o[1]===y)) cell.classList.add("obstacle");
            if(waypoints.some(w=>w[0]===x&&w[1]===y && !visitedWaypoints.some(vw=>vw[0]===w[0] && vw[1]===w[1]))) cell.classList.add("waypoint");
            if(x===goal[0]&&y===goal[1]) cell.classList.add("goal");
            if(x===robotPos[0]&&y===robotPos[1]) { cell.classList.add("robot"); cell.innerHTML="ğŸ¤–"; }
            grid.appendChild(cell);
        }
    }
}

function updateRobot(prevPos, newPos){
    let grid=document.getElementById("grid");
    let oldCell=grid.querySelector(`.cell[data-x='${prevPos[0]}'][data-y='${prevPos[1]}']`);
    if(oldCell){ oldCell.classList.remove("robot"); oldCell.innerHTML=""; }
    let newCell=grid.querySelector(`.cell[data-x='${newPos[0]}'][data-y='${newPos[1]}']`);
    if(newCell){ newCell.classList.add("robot"); newCell.innerHTML="ğŸ¤–"; }
    trajectoryPoints.push([...newPos]);

    if(newPos[0]===goal[0] && newPos[1]===goal[1]){
        endTime = performance.now();
        let elapsed = ((endTime - startTime)/1000).toFixed(2);
        document.getElementById("current-time").innerText = elapsed + " s";
        drawTrajectory();
    }

    waypoints.forEach(w=>{
        if(w[0]===newPos[0] && w[1]===newPos[1]){
            newCell.classList.remove("waypoint"); newCell.classList.add("visited"); newCell.innerHTML="ğŸ¤–";
            if(!visitedWaypoints.some(vw=>vw[0]===w[0] && vw[1]===w[1])) visitedWaypoints.push([w[0],w[1]]);
        }
    });
}

// ---------------- Äiá»u khiá»ƒn & Debug ----------------
async function manualMove(dir){
    if(!debugMode) return;
    let prevPos = [...robotPos];
    let resp = await fetch("/step",{ method:"POST", headers:{"Content-Type":"application/json"}, body:JSON.stringify({action_name:dir}) });
    let data=await resp.json();
    if(!data.error){ robotPos = data.state; visitedWaypoints = data.visited_waypoints || []; updateRobot(prevPos, robotPos); }
}
function toggleDebug(){ debugMode = !debugMode; document.getElementById("manualControls").style.display = debugMode?"block":"none"; }

// ---------------- Auto Move & Stop ----------------
let autoMode = "random";
function move(dx, dy) {
    let newX = robotPos[0] + dx, newY = robotPos[1] + dy;
    if (newX >= 0 && newX < gridSizeX && newY >= 0 && newY < gridSizeY && !obstacles.some(o => o[0] === newX && o[1] === newY)) {
        let prevPos = [...robotPos]; robotPos = [newX, newY]; trajectoryPoints.push([...robotPos]); updateRobot(prevPos, robotPos);
    }
}
function autoStepRandom() { const actions = [[0, 1], [0, -1], [1, 0], [-1, 0]]; let action = actions[Math.floor(Math.random() * actions.length)]; move(action[0], action[1]); }
function autoStepGreedy() {
    const actions = [[0, 1], [0, -1], [1, 0], [-1, 0]]; let bestAction = null, bestDist = Infinity;
    for (let [dx, dy] of actions) {
        let newX = robotPos[0] + dx, newY = robotPos[1] + dy;
        if (newX >= 0 && newX < gridSizeX && newY >= 0 && newY < gridSizeY && !obstacles.some(o => o[0] === newX && o[1] === newY)) {
            let dist = Math.abs(goal[0] - newX) + Math.abs(goal[1] - newY);
            if (dist < bestDist) { bestDist = dist; bestAction = [dx, dy]; }
        }
    }
    if (bestAction) move(bestAction[0], bestAction[1]);
}
function startAutoMove(mode = "random") {
    if (autoMoving) return; autoMoving = true; algoMoving = false; autoMode = mode;
    startTime = performance.now(); trajectoryPoints = [[...robotPos]];
    intervalId = setInterval(() => { if (autoMode === "random") autoStepRandom(); else if (autoMode === "greedy") autoStepGreedy(); }, 300);
    document.getElementById("msg").innerText = "Auto move (" + autoMode + ") báº¯t Ä‘áº§u";
}
function stopAll() {
    autoMoving = false; algoMoving = false; currentAlgo = null;
    if (intervalId) clearInterval(intervalId); intervalId = null;
    document.getElementById("msg").innerText = "ÄÃ£ dá»«ng robot"; document.getElementById("algoResult").style.display = "none";
}

// ---------------- Reset ----------------
async function resetGrid(){
    stopAll();
    let resp = await fetch("/reset",{method:"POST",headers:{"Content-Type":"application/json"},body:"{}"});
    let data = await resp.json();
    robotPos=data.state; goal=data.map.goal; obstacles=data.map.obstacles; waypoints=data.map.waypoints||[];
    visitedWaypoints=[]; gridSizeX=data.map.width; gridSizeY=data.map.height;
    drawGridOnce(); updateRobot([0,0], robotPos);
    document.getElementById("msg").innerText="MÃ´i trÆ°á»ng Ä‘Ã£ Ä‘Æ°á»£c reset";
    document.getElementById("current-time").innerText="-";
    trajectoryPoints=[]; clearTrajectory();
}
async function resetAllGrid(){
    stopAll();
    let resp = await fetch("/reset_all", {method:"POST"});
    let data = await resp.json();
    robotPos=data.state; goal=data.map.goal; obstacles=data.map.obstacles; waypoints=data.map.waypoints||[];
    visitedWaypoints=[]; gridSizeX=data.map.width; gridSizeY=data.map.height;
    drawGridOnce(); updateRobot([0,0], robotPos);
    allAlgoData = {}; rewardChart.data.labels = []; rewardChart.data.datasets = []; rewardChart.update();
    clearTrajectory();
    document.getElementById("msg").innerText="ğŸŒ Gridworld Ä‘Ã£ Ä‘Æ°á»£c reset toÃ n bá»™";
    updateStats("-", "-", "-", "-");
    document.getElementById("current-time").innerText="-";
}

// ---------------- Cháº¡y thuáº­t toÃ¡n ----------------

// CÅ¨: Cháº¡y tá»«ng bÆ°á»›c cho MC, Q-learning, A2C
async function runAlgorithmStepByStep(algo){
    stopAll(); currentAlgo = algo; allAlgoData[algo] = { rewards: [], color: randomColor() };
    let totalReward = 0, steps = 0;
    const resultDiv = document.getElementById("algoResult");
    resultDiv.style.display = "block"; resultDiv.innerHTML = `<div class="loading"></div> Äang cháº¡y ${algo}...`;
    await resetGrid();
    intervalId = setInterval(async () => {
        try {
            let prevPos = [...robotPos];
            const resp = await fetch("/step_algorithm", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ algorithm: algo }) });
            const data = await resp.json();
            if (data.error) { resultDiv.innerHTML = `âŒ Lá»—i: ${data.error}`; stopAll(); return; }
            robotPos = data.state; visitedWaypoints = data.visited_waypoints || [];
            updateRobot(prevPos, robotPos);
            totalReward += data.reward; steps = data.steps;
            allAlgoData[algo].rewards.push(totalReward);
            updateStats(algo, totalReward.toFixed(1), steps, `${visitedWaypoints.length}/${waypoints.length}`);
            if (data.done) {
                resultDiv.innerHTML = `âœ… <strong>${algo}</strong><br>ğŸ¯ Reward: ${totalReward.toFixed(1)}<br>ğŸ‘£ Steps: ${steps}<br>ğŸ† <strong>ÄÃ£ Ä‘áº¿n Ä‘Ã­ch!</strong>`;
                stopAll();
            } else { resultDiv.innerHTML = `<div class="loading"></div> Äang cháº¡y ${algo}...`; }
            updateChart();
        } catch (e) { console.error(e); resultDiv.innerHTML = "âŒ Lá»—i khi cháº¡y thuáº­t toÃ¡n"; stopAll(); }
    }, 200);
}

// Má»šI: Huáº¥n luyá»‡n rá»“i cháº¡y cho SARSA
async function trainAndRunSarsa() {
    stopAll(); currentAlgo = "SARSA";
    const resultDiv = document.getElementById("algoResult");
    resultDiv.style.display = "block";
    resultDiv.innerHTML = `<div class="loading"></div> Äang huáº¥n luyá»‡n SARSA (cÃ³ thá»ƒ máº¥t vÃ i giÃ¢y)...`;
    await resetGrid(); 
    
    try {
        const resp = await fetch("/train_and_run_sarsa", {
            method: "POST", headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ episodes: 2000 })
        });
        const data = await resp.json();

        if (data.error) { resultDiv.innerHTML = `âŒ Lá»—i: ${data.error}`; return; }
        allAlgoData[data.algorithm] = { rewards: data.rewards_over_time, color: randomColor() };

        let path = data.path;
        for (let i = 1; i < path.length; i++) {
            await new Promise(r => setTimeout(r, 50));
            let prevPos = [...robotPos]; robotPos = path[i];
            updateRobot(prevPos, robotPos);
        }

        updateStats(data.algorithm, data.reward.toFixed(1), data.steps, `${data.visited_waypoints.length}/${waypoints.length}`);
        document.getElementById("current-time").innerText = `${data.elapsed_time.toFixed(2)} s (server)`;

        resultDiv.innerHTML = `
            âœ… <strong>${data.algorithm}</strong> (${data.info.note})<br>
            ğŸ¯ Reward: ${data.reward.toFixed(1)}<br>
            ğŸ‘£ Steps: ${data.steps}<br>
            ğŸ“ Waypoints: ${data.visited_waypoints.length}/${waypoints.length}<br>
            ${data.done ? "ğŸ† <strong>Robot Ä‘Ã£ Ä‘áº¿n Ä‘Ã­ch!</strong>" : "âš ï¸ <strong>KhÃ´ng Ä‘áº¿n Ä‘Æ°á»£c Ä‘Ã­ch.</strong>"}
        `;
        updateChart();
        drawTrajectory();
    } catch (e) {
        console.error(e); resultDiv.innerHTML = "âŒ CÃ³ lá»—i xáº£y ra khi cháº¡y SARSA";
    }
}

// Cháº¡y A*
async function runAStar(){
    stopAll(); currentAlgo="A*";
    const resultDiv = document.getElementById("algoResult");
    resultDiv.style.display = "block"; resultDiv.innerHTML = `<div class="loading"></div> Äang cháº¡y A*...`;
    try{
        let prevPos = [...robotPos];
        const resp = await fetch("/run_a_star",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({})});
        const data = await resp.json();
        if(data.error){ resultDiv.innerHTML = `âŒ Lá»—i: ${data.error}`; return; }
        allAlgoData[data.algorithm] = { rewards: data.rewards_over_time, color: randomColor() };
        let path = data.path;
        for(let i=1;i<path.length;i++){
            await new Promise(r=>setTimeout(r,50));
            prevPos = [...robotPos]; robotPos = path[i];
            updateRobot(prevPos, robotPos);
        }
        updateStats(data.algorithm, data.reward.toFixed(1), data.steps, `${data.visited_waypoints.length}/${waypoints.length}`);
        document.getElementById("current-time").innerText = `${data.elapsed_time.toFixed(2)} s`;
        resultDiv.innerHTML = `âœ… <strong>${data.algorithm}</strong><br>ğŸ¯ Reward: ${data.reward.toFixed(1)}<br>ğŸ‘£ Steps: ${data.steps}<br>${data.done ? "ğŸ† <strong>ÄÃ£ Ä‘áº¿n Ä‘Ã­ch!</strong>" : ""}`;
        updateChart(); drawTrajectory();
    } catch(e){ console.error(e); resultDiv.innerHTML = "âŒ CÃ³ lá»—i xáº£y ra khi cháº¡y A*"; }
}

// ---------------- Váº½ Ä‘Æ°á»ng Ä‘i & Cáº­p nháº­t Stats ----------------
function drawTrajectory(){
    let canvas=document.getElementById("trajectory"), ctx=canvas.getContext("2d");
    clearTrajectory(); if(trajectoryPoints.length<2) return;
    ctx.beginPath();
    let scaleX=canvas.width/gridSizeX, scaleY=canvas.height/gridSizeY;
    ctx.moveTo(trajectoryPoints[0][0]*scaleX+scaleX/2, trajectoryPoints[0][1]*scaleY+scaleY/2);
    for(let i=1;i<trajectoryPoints.length;i++){ ctx.lineTo(trajectoryPoints[i][0]*scaleX+scaleX/2, trajectoryPoints[i][1]*scaleY+scaleY/2); }
    ctx.strokeStyle="red"; ctx.lineWidth=2; ctx.stroke();
}
function clearTrajectory(){ let canvas=document.getElementById("trajectory"); canvas.getContext("2d").clearRect(0,0,canvas.width,canvas.height); }
function updateStats(algo, reward, steps, wp){
    document.getElementById("current-algorithm").innerText = algo;
    document.getElementById("current-reward").innerText = reward;
    document.getElementById("current-steps").innerText = steps;
    document.getElementById("current-waypoints").innerText = wp;
}

// ---------------- Khá»Ÿi táº¡o ----------------
window.onload = resetGrid;
</script>

</body>
</html>
